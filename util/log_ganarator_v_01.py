# Form implementation generated from reading ui file 'generateLogs.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from db_operation_functions import queryComposer
import datetime
import numpy as np


def generate_smooth_curve(start, end, num_points, window_size=10):
    # Generate some random values
    x = np.linspace(start, end, num_points)
    y = np.random.uniform(start, end, num_points)

    # calculating filter with sliding window

    weights = np.repeat(1.0, window_size) / window_size

    # fill edges with values
    padded_y = np.pad(y, (window_size - 1, window_size - 1), mode="edge")

    # applying filter to values
    smoothed_y = np.convolve(padded_y, weights, "valid")

    # interpolate to restore amount of points
    xp = np.linspace(start, end, len(smoothed_y))
    fp = np.interp(x, xp, smoothed_y)

    return fp


def drop_init(smooth_curve, break_value, rise_part=5, drop_part=5):
    # calculate point where thing start getting weird
    n_arr = len(smooth_curve)
    break_point = np.random.random() / 5 + 0.2
    # 1/5 of array size
    # gradual rise
    rise_pos = int(n_arr * break_point)
    # drop to zero
    drop_pos = int(rise_pos + n_arr / rise_part)
    # rise to normal value
    up_pos = int(drop_pos + n_arr / drop_part)
    # avg smooth val
    avg_val = np.average(smooth_curve)
    # slope calc
    # slope = calculate_slope(rise_pos, avg_val, drop_pos, break_value)
    # adding rise section
    smooth_curve[rise_pos:drop_pos] = smooth_curve[rise_pos:drop_pos] + np.linspace(
        0, break_value - avg_val, drop_pos - rise_pos
    )
    # adding zero section
    smooth_curve[drop_pos:up_pos] = 0


def random_smoth_line(
    time_step: float,
    arr_size: int,
    max_value: float,
    st_pos: float = None,
    grad_adjustment: float = 1,
):
    if st_pos is None:
        st_pos = np.random.randint(0, max_value)
    res = [st_pos]
    counter = 0
    for _ in range(arr_size - 1):
        if counter == 0:
            counter = np.random.randint(1, int(0.05 * arr_size / grad_adjustment))
            dydx_ = (
                grad_adjustment
                * (np.random.random() - 0.5)
                * 0.01
                * max_value
                / time_step
            )
        counter -= 1
        tmp = res[-1] + time_step * dydx_
        if tmp <= 0:
            counter = 0
            tmp = 0.1
        elif tmp >= max_value:
            counter = 0
            tmp = max_value - 0.1
        res.append(tmp)
    return res


def smooth_rejection(arr_size: int, max_value: float):
    x = np.linspace(0, 100, arr_size)

    def sigma_func(x, L, k):
        return L / (1 + np.exp(-k * x))

    res = sigma_func(x, max_value * 0.9, 0.1)
    return list(res)


def sharp_rej(arr_size: int, max_value: float, pos: float = 0.2):
    bf_br_n = int(pos * arr_size)
    af_br_n = arr_size - bf_br_n
    bf_dx = 100 / bf_br_n
    af_dx = 100 / af_br_n
    bf_br_list = np.array(random_smoth_line(bf_dx, bf_br_n, max_value * 0.5))
    af_br_list = max_value * 0.8 + np.array(
        random_smoth_line(af_dx, af_br_n, max_value * 0.2)
    )
    fina = np.concatenate([bf_br_list, af_br_list])
    return list(fina)


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(715, 255)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(280, 170, 95, 30))
        self.pushButton.setObjectName("pushButton")
        self.listWidget = QtWidgets.QListWidget(parent=self.centralwidget)
        self.listWidget.setGeometry(QtCore.QRect(10, 5, 255, 190))
        self.listWidget.setObjectName("listWidget")
        self.gridLayoutWidget = QtWidgets.QWidget(parent=self.centralwidget)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(280, 10, 410, 115))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.intervalField = QtWidgets.QLineEdit(parent=self.gridLayoutWidget)
        self.intervalField.setValidator(QtGui.QIntValidator(1, 100))
        self.intervalField.setObjectName("intervalField")
        self.intervalField.setText("1")
        self.gridLayout.addWidget(self.intervalField, 2, 1, 1, 1)
        self.nameLabel = QtWidgets.QLabel(parent=self.gridLayoutWidget)
        self.nameLabel.setObjectName("nameLabel")
        self.gridLayout.addWidget(self.nameLabel, 0, 0, 1, 1)
        self.intervalVal = QtWidgets.QLabel(parent=self.gridLayoutWidget)
        self.intervalVal.setObjectName("intervalVal")
        self.gridLayout.addWidget(self.intervalVal, 2, 0, 1, 1)
        self.limitField = QtWidgets.QLabel(parent=self.gridLayoutWidget)
        self.limitField.setText("")
        self.limitField.setObjectName("limitField")
        self.gridLayout.addWidget(self.limitField, 1, 1, 1, 1)
        self.nameField = QtWidgets.QLabel(parent=self.gridLayoutWidget)
        self.nameField.setText("")
        self.nameField.setObjectName("nameField")
        self.gridLayout.addWidget(self.nameField, 0, 1, 1, 1)
        self.limitLabel = QtWidgets.QLabel(parent=self.gridLayoutWidget)
        self.limitLabel.setObjectName("limitLabel")
        self.gridLayout.addWidget(self.limitLabel, 1, 0, 1, 1)
        self.horizontalLayoutWidget = QtWidgets.QWidget(parent=self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(280, 140, 410, 20))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.button_group = QtWidgets.QButtonGroup()
        self.button_group.setExclusive(True)

        self.normal_mode_button = QtWidgets.QRadioButton()
        self.button_group.addButton(self.normal_mode_button)
        self.normal_mode_button.setChecked(True)
        self.normal_mode_button.setObjectName("normal_mode_button")
        self.horizontalLayout.addWidget(self.normal_mode_button)
        self.smooth_drop_button = QtWidgets.QRadioButton()
        self.button_group.addButton(self.smooth_drop_button)

        self.smooth_drop_button.setObjectName("smooth_drop_button")
        self.horizontalLayout.addWidget(self.smooth_drop_button)

        self.sudden_drop_button = QtWidgets.QRadioButton()
        self.horizontalLayout.addWidget(self.sudden_drop_button)
        self.sudden_drop_button.setObjectName("sudden_drop_button")

        self.button_group.addButton(self.sudden_drop_button)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 715, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.listWidget.currentItemChanged.connect(self.list_clicked_slot)
        self.pushButton.clicked.connect(self.generate_button_slot)
        self.sensor_data_loader()
        self.sensor_data_placeholder()

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(
            _translate("MainWindow", "Генератор значений для датчиков")
        )
        self.pushButton.setText(_translate("MainWindow", "Генерация"))
        self.nameLabel.setText(_translate("MainWindow", "Название"))
        self.intervalVal.setText(_translate("MainWindow", "Интервал"))
        self.limitLabel.setText(_translate("MainWindow", "Предельное значение"))
        self.normal_mode_button.setText(
            _translate("MainWindow", "Нормальный режим работы")
        )
        self.smooth_drop_button.setText(_translate("MainWindow", "Плавный отказ"))
        self.sudden_drop_button.setText(_translate("MainWindow", "Внезапный отказ"))

    def sensor_data_loader(self):
        qc = queryComposer("sensor")
        raw_data = qc.select_query(
            order_opt=["sensor_id"],
        )
        qc.close_connection()
        self.sensor_data_id_ref = {sensor["sensor_id"]: sensor for sensor in raw_data}

    def sensor_data_placeholder(self):
        for sensor in self.sensor_data_id_ref.values():
            self.listWidget.addItem(sensor["sensor_name"])
        self.listWidget.setCurrentRow(0)

    def list_clicked_slot(self):
        self.current_data = self.sensor_data_id_ref[
            list(self.sensor_data_id_ref.keys())[self.listWidget.currentRow()]
        ]
        self.nameField.setText(self.current_data["sensor_name"])
        self.limitField.setText(str(self.current_data["limit_mode_value"]))

    def generate_button_slot(self):
        """ """
        self.clear_logs()
        interval = int(self.intervalField.text())
        # fill past 7 days with chosen regime
        c_time = datetime.datetime.now().replace(microsecond=0)
        lower_time_edge = c_time - datetime.timedelta(days=7)
        # record each 15 minutes for the first 6 days of past week

        dtime = 10 * 60

        # size of an value array
        w_list_dim = int(6 * 24 * 60 * 60 / dtime)

        out_val = generate_smooth_curve(
            0.2 * self.current_data["limit_mode_value"],
            0.6 * self.current_data["limit_mode_value"],
            w_list_dim,
        )

        # random values to fill 7days before

        # out_val = random_smoth_line(
        #     5, w_list_dim, self.current_data["limit_mode_value"]
        # )

        # query markup dict init
        data_template = {"sensor_id": self.current_data["sensor_id"]}

        # apply workmode
        # print(self.normal_mode_button.isEnabled(), self.normal_mode_button.isChecked())
        # print(self.smooth_drop_button.isEnabled(), self.smooth_drop_button.isChecked())
        # print(self.sudden_drop_button.isEnabled(), self.sudden_drop_button.isChecked())
        if self.smooth_drop_button.isChecked():
            drop_init(out_val, 0.85 * self.current_data["limit_mode_value"], 2, 10)
        elif self.sudden_drop_button.isChecked():
            drop_init(out_val, 0.85 * self.current_data["limit_mode_value"], 20, 10)
        # data sent to database
        qc = queryComposer("sensor_logs")
        for idx, val in enumerate(out_val):
            data_template["log_datetime"] = lower_time_edge + datetime.timedelta(
                seconds=idx * dtime
            )
            data_template["sensor_value"] = val
            qc.insert_query(data_template)
        # data for the first 23 hours of last day
        lower_time_edge = c_time - datetime.timedelta(days=1)
        # minute interval here for better resolution
        dtime = 60 * 2
        # size of an array
        w_list_dim = int(23 * 60 * 60 / dtime)
        # generate data stable data for the last day
        out_val = generate_smooth_curve(
            0.19 * self.current_data["limit_mode_value"],
            0.59 * self.current_data["limit_mode_value"],
            w_list_dim,
        )

        # out_val = random_smoth_line(
        #     5, w_list_dim, self.current_data["limit_mode_value"], out_val[-1], 0.4
        # )

        # send data to database via qc
        for idx, val in enumerate(out_val):
            data_template["log_datetime"] = lower_time_edge + datetime.timedelta(
                seconds=idx * dtime
            )
            data_template["sensor_value"] = val
            qc.insert_query(data_template)

        # hour before generation
        lower_time_edge = c_time - datetime.timedelta(hours=1)
        # time delta is 5 seconds, for better resolution
        dtime = 5
        # size of an array
        w_list_dim = int(60 * 60 / dtime)
        # generate smooth line
        out_val = generate_smooth_curve(
            0.1 * self.current_data["limit_mode_value"],
            0.5 * self.current_data["limit_mode_value"],
            w_list_dim,
        )
        # out_val = random_smoth_line(
        #     5, w_list_dim, self.current_data["limit_mode_value"], out_val[-1], 0.2
        # )
        for idx, val in enumerate(out_val):
            data_template["log_datetime"] = lower_time_edge + datetime.timedelta(
                seconds=idx * dtime
            )
            data_template["sensor_value"] = val
            qc.insert_query(data_template)
        # data for further 2 hours
        list_dim = int(2 * 60 * 60 / interval)
        # if self.normal_mode_button.isChecked():
        #     flat_list = random_smoth_line(
        #         interval, list_dim, self.current_data["limit_mode_value"]
        #     )
        # elif self.smooth_drop_button.isChecked:
        #     flat_list = smooth_rejection(
        #         list_dim, self.current_data["limit_mode_value"]
        #     )
        # elif self.sudden_drop_button.isChecked:
        #     flat_list = sharp_rej(list_dim, self.current_data["limit_mode_value"])
        # else:
        #     flat_list = random_smoth_line(
        #         interval,
        #         list_dim,
        #         self.current_data["limit_mode_value"],
        #         grad_adjustment=0.1,
        #     )

        # data generation
        flat_list = generate_smooth_curve(
            0.05 * self.current_data["limit_mode_value"],
            0.65 * self.current_data["limit_mode_value"],
            list_dim,
        )
        # data sent
        for idx, val in enumerate(flat_list):
            data_template["log_datetime"] = c_time + datetime.timedelta(
                seconds=idx * interval
            )
            data_template["sensor_value"] = val
            qc.insert_query(data_template)
        qc.close_connection()

    def clear_logs(self):
        c_time = datetime.datetime.now().replace(microsecond=0)
        del_time = c_time - datetime.timedelta(days=7)
        qc = queryComposer("sensor_logs")
        cond = [
            {
                "key_name": "sensor_id",
                "comp_operand": "=",
                "key_value": self.current_data["sensor_id"],
            },
            {
                "key_name": "log_datetime",
                "comp_operand": ">=",
                "key_value": del_time,
            },
        ]
        qc.delete_query(conditions=cond)
        qc.close_connection()


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
